{"message":"cannot find type `Punctuator` in this scope","code":{"code":"E0412","explanation":"\nThe type name used is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/lib/syntax/ast/token.rs","byte_start":635,"byte_end":645,"line_start":27,"line_end":27,"column_start":17,"column_end":27,"is_primary":true,"text":[{"text":"    TPunctuator(Punctuator),","highlight_start":17,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `Punctuator` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/syntax/ast/token.rs:27:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    TPunctuator(Punctuator),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"not all trait items implemented, missing: `Err`","code":{"code":"E0046","explanation":"\nItems are missing in a trait implementation. Erroneous code example:\n\n```compile_fail,E0046\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {}\n// error: not all trait items implemented, missing: `foo`\n```\n\nWhen trying to make some type implement a trait `Foo`, you must, at minimum,\nprovide implementations for all of `Foo`'s required methods (meaning the\nmethods that do not have default implementations), as well as any required\ntrait items like associated types or constants. Example:\n\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo() {} // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib/syntax/ast/keyword.rs","byte_start":1451,"byte_end":1475,"line_start":72,"line_end":72,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"impl FromStr for Keyword {","highlight_start":1,"highlight_end":25}],"label":"missing `Err` in implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"implement the missing item: `type Err = Type;`","code":null,"level":"help","spans":[{"file_name":"src/lib/syntax/ast/keyword.rs","byte_start":2689,"byte_end":2689,"line_start":109,"line_end":109,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"type Err = Type;\n","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0046]\u001b[0m\u001b[0m\u001b[1m: not all trait items implemented, missing: `Err`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/syntax/ast/keyword.rs:72:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl FromStr for Keyword {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmissing `Err` in implementation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: \u001b[0m\u001b[0mimplement the missing item: `type Err = Type;`\u001b[0m\n\n"}
{"message":"method `fmt` has an incompatible type for trait","code":{"code":"E0053","explanation":"\nThe parameters of any trait method must match between a trait implementation\nand the trait definition.\n\nHere are a couple examples of this error:\n\n```compile_fail,E0053\ntrait Foo {\n    fn foo(x: u16);\n    fn bar(&self);\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    // error, expected u16, found i16\n    fn foo(x: i16) { }\n\n    // error, types differ in mutability\n    fn bar(&mut self) { }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib/syntax/ast/keyword.rs","byte_start":2722,"byte_end":2780,"line_start":111,"line_end":111,"column_start":5,"column_end":63,"is_primary":true,"text":[{"text":"    fn fmt(&self, f: &mut Formatter) -> Result<String, String> {","highlight_start":5,"highlight_end":63}],"label":"expected (), found struct `std::string::String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type `fn(&syntax::ast::keyword::Keyword, &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error>`\n   found type `fn(&syntax::ast::keyword::Keyword, &mut std::fmt::Formatter<'_>) -> std::result::Result<std::string::String, std::string::String>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0053]\u001b[0m\u001b[0m\u001b[1m: method `fmt` has an incompatible type for trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/syntax/ast/keyword.rs:111:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn fmt(&self, f: &mut Formatter) -> Result<String, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected (), found struct `std::string::String`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type `\u001b[0m\u001b[0m\u001b[1mfn(&syntax::ast::keyword::Keyword, &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found type `\u001b[0m\u001b[0m\u001b[1mfn(&syntax::ast::keyword::Keyword, &mut std::fmt::Formatter<'_>) -> std::result::Result<std::string::String, std::string::String>\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"match arms have incompatible types","code":{"code":"E0308","explanation":"\nThis error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/lib/syntax/ast/keyword.rs","byte_start":3968,"byte_end":3979,"line_start":147,"line_end":147,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"                _ => Err(\"ahgh\"),","highlight_start":22,"highlight_end":33}],"label":"expected &str, found enum `std::result::Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib/syntax/ast/keyword.rs","byte_start":2844,"byte_end":3994,"line_start":115,"line_end":148,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            match *self {","highlight_start":13,"highlight_end":26},{"text":"                KBreak => \"break\",","highlight_start":1,"highlight_end":35},{"text":"                KCase => \"case\",","highlight_start":1,"highlight_end":33},{"text":"                KCatch => \"catch\",","highlight_start":1,"highlight_end":35},{"text":"                KClass => \"class\",","highlight_start":1,"highlight_end":35},{"text":"                KContinue => \"continue\",","highlight_start":1,"highlight_end":41},{"text":"                KDebugger => \"debugger\",","highlight_start":1,"highlight_end":41},{"text":"                KDefault => \"default\",","highlight_start":1,"highlight_end":39},{"text":"                KDelete => \"delete\",","highlight_start":1,"highlight_end":37},{"text":"                KDo => \"do\",","highlight_start":1,"highlight_end":29},{"text":"                KElse => \"else\",","highlight_start":1,"highlight_end":33},{"text":"                KEnum => \"enum\",","highlight_start":1,"highlight_end":33},{"text":"                KExtends => \"extends\",","highlight_start":1,"highlight_end":39},{"text":"                KFinally => \"finally\",","highlight_start":1,"highlight_end":39},{"text":"                KFor => \"for\",","highlight_start":1,"highlight_end":31},{"text":"                KFunction => \"function\",","highlight_start":1,"highlight_end":41},{"text":"                KIf => \"if\",","highlight_start":1,"highlight_end":29},{"text":"                KIn => \"in\",","highlight_start":1,"highlight_end":29},{"text":"                KInstanceOf => \"instanceof\",","highlight_start":1,"highlight_end":45},{"text":"                KImport => \"import\",","highlight_start":1,"highlight_end":37},{"text":"                KNew => \"new\",","highlight_start":1,"highlight_end":31},{"text":"                KReturn => \"return\",","highlight_start":1,"highlight_end":37},{"text":"                KSuper => \"super\",","highlight_start":1,"highlight_end":35},{"text":"                KSwitch => \"switch\",","highlight_start":1,"highlight_end":37},{"text":"                KThis => \"this\",","highlight_start":1,"highlight_end":33},{"text":"                KThrow => \"throw\",","highlight_start":1,"highlight_end":35},{"text":"                KTry => \"try\",","highlight_start":1,"highlight_end":31},{"text":"                KTypeOf => \"typeof\",","highlight_start":1,"highlight_end":37},{"text":"                KVar => \"var\",","highlight_start":1,"highlight_end":31},{"text":"                KVoid => \"void\",","highlight_start":1,"highlight_end":33},{"text":"                KWhile => \"while\",","highlight_start":1,"highlight_end":35},{"text":"                KWith => \"with\",","highlight_start":1,"highlight_end":33},{"text":"                _ => Err(\"ahgh\"),","highlight_start":1,"highlight_end":34},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib/syntax/ast/keyword.rs","byte_start":3939,"byte_end":3945,"line_start":146,"line_end":146,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"                KWith => \"with\",","highlight_start":26,"highlight_end":32}],"label":"this and all prior arms are found to be of type `&str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type `&str`\n   found type `std::result::Result<_, &str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: match arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/syntax/ast/keyword.rs:147:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match *self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                KBreak => \"break\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                KCase => \"case\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m118\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                KCatch => \"catch\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                KWith => \"with\",\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis and all prior arms are found to be of type `&str`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                _ => Err(\"ahgh\"),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected &str, found enum `std::result::Result`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`match` arms have incompatible types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type `\u001b[0m\u001b[0m\u001b[1m&str\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found type `\u001b[0m\u001b[0m\u001b[1mstd::result::Result<_, &str>\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"\nThis error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"<::core::macros::write macros>","byte_start":37,"byte_end":95,"line_start":2,"line_end":2,"column_start":2,"column_end":60,"is_primary":true,"text":[{"text":"($ dst . write_fmt ($ crate :: format_args ! ($ ($ arg) *)))","highlight_start":2,"highlight_end":60}],"label":"expected struct `std::string::String`, found ()","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/syntax/ast/keyword.rs","byte_start":2791,"byte_end":4004,"line_start":112,"line_end":149,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        write!(","highlight_start":9,"highlight_end":16},{"text":"            f,","highlight_start":1,"highlight_end":15},{"text":"            \"{}\",","highlight_start":1,"highlight_end":18},{"text":"            match *self {","highlight_start":1,"highlight_end":26},{"text":"                KBreak => \"break\",","highlight_start":1,"highlight_end":35},{"text":"                KCase => \"case\",","highlight_start":1,"highlight_end":33},{"text":"                KCatch => \"catch\",","highlight_start":1,"highlight_end":35},{"text":"                KClass => \"class\",","highlight_start":1,"highlight_end":35},{"text":"                KContinue => \"continue\",","highlight_start":1,"highlight_end":41},{"text":"                KDebugger => \"debugger\",","highlight_start":1,"highlight_end":41},{"text":"                KDefault => \"default\",","highlight_start":1,"highlight_end":39},{"text":"                KDelete => \"delete\",","highlight_start":1,"highlight_end":37},{"text":"                KDo => \"do\",","highlight_start":1,"highlight_end":29},{"text":"                KElse => \"else\",","highlight_start":1,"highlight_end":33},{"text":"                KEnum => \"enum\",","highlight_start":1,"highlight_end":33},{"text":"                KExtends => \"extends\",","highlight_start":1,"highlight_end":39},{"text":"                KFinally => \"finally\",","highlight_start":1,"highlight_end":39},{"text":"                KFor => \"for\",","highlight_start":1,"highlight_end":31},{"text":"                KFunction => \"function\",","highlight_start":1,"highlight_end":41},{"text":"                KIf => \"if\",","highlight_start":1,"highlight_end":29},{"text":"                KIn => \"in\",","highlight_start":1,"highlight_end":29},{"text":"                KInstanceOf => \"instanceof\",","highlight_start":1,"highlight_end":45},{"text":"                KImport => \"import\",","highlight_start":1,"highlight_end":37},{"text":"                KNew => \"new\",","highlight_start":1,"highlight_end":31},{"text":"                KReturn => \"return\",","highlight_start":1,"highlight_end":37},{"text":"                KSuper => \"super\",","highlight_start":1,"highlight_end":35},{"text":"                KSwitch => \"switch\",","highlight_start":1,"highlight_end":37},{"text":"                KThis => \"this\",","highlight_start":1,"highlight_end":33},{"text":"                KThrow => \"throw\",","highlight_start":1,"highlight_end":35},{"text":"                KTry => \"try\",","highlight_start":1,"highlight_end":31},{"text":"                KTypeOf => \"typeof\",","highlight_start":1,"highlight_end":37},{"text":"                KVar => \"var\",","highlight_start":1,"highlight_end":31},{"text":"                KVoid => \"void\",","highlight_start":1,"highlight_end":33},{"text":"                KWhile => \"while\",","highlight_start":1,"highlight_end":35},{"text":"                KWith => \"with\",","highlight_start":1,"highlight_end":33},{"text":"                _ => Err(\"ahgh\"),","highlight_start":1,"highlight_end":34},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"write!","def_site_span":{"file_name":"<::core::macros::write macros>","byte_start":0,"byte_end":96,"line_start":1,"line_end":2,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"($ dst : expr, $ ($ arg : tt) *) =>","highlight_start":1,"highlight_end":36},{"text":"($ dst . write_fmt ($ crate :: format_args ! ($ ($ arg) *)))","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib/syntax/ast/keyword.rs","byte_start":2758,"byte_end":2780,"line_start":111,"line_end":111,"column_start":41,"column_end":63,"is_primary":false,"text":[{"text":"    fn fmt(&self, f: &mut Formatter) -> Result<String, String> {","highlight_start":41,"highlight_end":63}],"label":"expected `std::result::Result<std::string::String, std::string::String>` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type `std::result::Result<std::string::String, std::string::String>`\n   found type `std::result::Result<(), std::fmt::Error>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/syntax/ast/keyword.rs:112:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    fn fmt(&self, f: &mut Formatter) -> Result<String, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `std::result::Result<std::string::String, std::string::String>` because of return type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        write!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            f,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            \"{}\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match *self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        )\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected struct `std::string::String`, found ()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type `std::result::Result<\u001b[0m\u001b[0m\u001b[1mstd::string::String\u001b[0m\u001b[0m, std::\u001b[0m\u001b[0m\u001b[1mstring::String\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found type `std::result::Result<\u001b[0m\u001b[0m\u001b[1m()\u001b[0m\u001b[0m, std::\u001b[0m\u001b[0m\u001b[1mfmt::Error\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 5 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 5 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0046, E0053, E0308, E0412.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0046, E0053, E0308, E0412.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0046`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0046`.\u001b[0m\n"}
